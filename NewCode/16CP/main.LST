C51 COMPILER V9.53.0.0   MAIN                                                              06/10/2017 00:58:18 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: F:\Keil_v5\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          //-----------------------------------------------------------------------------
   2          // Includes
   3          //-----------------------------------------------------------------------------
   4          #include "compiler_defs.h"
   5          #include "C8051F500_defs.h"            // SFR declarations
   6          #include "Display.h"
   7          //-----------------------------------------------------------------------------
   8          // Type Definitions
   9          //-----------------------------------------------------------------------------
  10          
  11          typedef union UU64
  12          {
  13             U32 U32[2];
  14             U16 U16[4];
  15             U8 U8[8];
  16          } UU64;
  17          
  18          //-----------------------------------------------------------------------------
  19          // Function Prototypes
  20          //-----------------------------------------------------------------------------
  21          
  22          void OSCILLATOR_Init (void);
  23          void PORT_Init (void);
  24          void CAN0_Init (void);
  25          void ADC0_Init(void);
  26          void Timer_Init(void);
  27          
  28          void PressureCal();
  29          void PIDControl();
  30          
  31          void CAN0_TransferMO (U8 obj_num);
  32          void Yunzhuanwei(void);
  33          void Chuzhiwei(void);
  34          void Quanzhidongwei(void);
  35          void Yizhiwei(void);
  36          void Chonglianwei(void);
  37          void Jinjiwei(void);
  38          void Ceya();
  39          
  40          INTERRUPT_PROTO (CAN0_ISR, INTERRUPT_CAN0);
  41          INTERRUPT_PROTO (TIMER0_ISR, INTERRUPT_TIMER0);
  42          INTERRUPT_PROTO (TIMER2_ISR, INTERRUPT_TIMER2);
  43          INTERRUPT_PROTO (TIMER3_ISR, INTERRUPT_TIMER3);
  44          INTERRUPT_PROTO (ADC0_ISR, INTERRUPT_ADC0_EOC);
  45          
  46          //-----------------------------------------------------------------------------
  47          // Global Constants
  48          //-----------------------------------------------------------------------------
  49          
  50          #define SYSCLK       24000000          // System clock speed in Hz
  51          
  52          #define MESSAGE_OBJECTS    32          // Number of message objects to use
  53                                                 // Range is 1-32
  54          #define MESSAGE_SIZE        8          // Size in bytes of each CAN message
  55                                                 // Range is 1-8
C51 COMPILER V9.53.0.0   MAIN                                                              06/10/2017 00:58:18 PAGE 2   

  56          
  57          #define RX_COMPLETE_MASK  0xFFFFFFFF   // Set this to (2^MESSAGE_OBJECTS - 1)
  58          
  59          //-----------------------------------------------------------------------------
  60          // Bit Definition Masks
  61          //-----------------------------------------------------------------------------
  62          
  63          // CAN0STAT
  64          #define BOff  0x80                     // Busoff Status
  65          #define EWarn 0x40                     // Warning Status
  66          #define EPass 0x20                     // Error Passive
  67          #define RxOk  0x10                     // Receive Message Successfully
  68          #define TxOk  0x08                     // Transmitted Message Successfully
  69          #define LEC   0x07                     // Last Error Code
  70          
  71          //-----------------------------------------------------------------------------
  72          // Pin Definitions
  73          //-----------------------------------------------------------------------------
  74          
  75          SBIT (LED, SFR_P1, 3);                 // LED = 1 turns on the LED
  76          
  77          //-----------------------------------------------------------------------------
  78          // Global Variables
  79          //-----------------------------------------------------------------------------
  80          #define IPM_ID 0x001
  81          #define EBV_ID 0x002
  82          #define Broadcast_ID 0x003
  83          #define ERCP_ID 0x010
  84          #define BPCP_ID 0x011
  85          #define CP16_ID 0x012
  86          #define CP20_ID 0x013
  87          #define CP13_ID 0x014
  88          #define TIMER2_RELOAD  200000000
  89          #define ANALOG_INPUTS    2
  90          #define INT_DEC             256        // Integrate and decimate ratio
  91          #define MV16_ON (P1 &= ~0x40)
  92          #define MV16_OFF (P1 |= 0x40)
  93          #define APP_ON ( P2 &= ~0x40)
  94          #define APP_OFF (P2 |= 0x40)
  95          #define REL_ON (P2 &= ~0x80)
  96          #define REL_OFF (P2 |= 0x80)
  97          //dispaly number define
  98          U8 dis[10]={ 0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90 };
  99                             //   0    1    2    3    4    5    6    7    8    9 
 100          bit CAN_ERROR = 0;                     // 0 = No Errors occurred
 101                                                 // 1 = Some error(s) occurred
 102          U8 FaultCode = 0x00;
 103          U8 CAN_Tx_Buf[8] = {0xf1, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};
 104          U8 CAN_Rx_Buf[8];
 105          U8 CAN_RX_COMPLETE;     
 106          U8 Rx_BPCP_OK = 0;             
 107          
 108          
 109          SEGMENT_VARIABLE (RESULT[ANALOG_INPUTS], U32, xdata);
 110          U8 PIN_TABLE[ANALOG_INPUTS] = {0x00, 0x01};
 111          U32 accumulator[ANALOG_INPUTS];
 112          U8 AMUX_INPUT = 0;
 113          U8 PWM_Count = 0;
 114          U8 PWM_Period = 100;
 115          U8 PWM_APP = 0;
 116          U8 PWM_REL = 0;
 117          
C51 COMPILER V9.53.0.0   MAIN                                                              06/10/2017 00:58:18 PAGE 3   

 118          U32 Target_ERT_Pressure  ;
 119          
 120          U32 pressure_current_ERT;
 121          U16 pressureERT_H;
 122          U16 pressureERT_L;
 123          float P_mA_current_ERT=0 ;
 124          
 125          
 126          U32 pressure_current_MRT;
 127          U16 pressureMRT_H;
 128          U16 pressureMRT_L;
 129          float P_mA_current_MRT=0 ;
 130          
 131          float error, sumerror, lasterror, kp, ki, kd;
 132          U32 TxCount;
 133          //-----------------------------------------------------------------------------
 134          // MAIN Routine
 135          //-----------------------------------------------------------------------------
 136          
 137          void main (void)
 138          {
 139   1      
 140   1         SFRPAGE = ACTIVE_PAGE;              // Set for PCA0MD
 141   1      
 142   1         PCA0MD &= ~0x40;                    // Disable Watchdog Timer
 143   1      
 144   1         OSCILLATOR_Init ();                 // Initialize oscillator
 145   1         PORT_Init ();                       // Initialize crossbar and GPIO
 146   1         CAN0_Init ();                       // Start CAN peripheral
 147   1         ADC0_Init ();
 148   1         Timer_Init ();
 149   1      
 150   1        //  EIE1 |= 0x40;
 151   1         EIE2 |= 0x02;                       // Enable CAN interupts
 152   1         EA = 1;                             // Enable global interrupts
 153   1         P2 |= 0xC0;
 154   1         while (1)
 155   1         {
 156   2            smg_display(1, 6, 0xc, 18);
 157   2            if(Rx_BPCP_OK)
 158   2            {
 159   3              CAN0_TransferMO(CP13_ID);
 160   3              CAN0_TransferMO(IPM_ID);
 161   3              Rx_BPCP_OK = 0;
 162   3            }
 163   2            // if( CAN_Rx_Buf[1] == 0x01)
 164   2           {
 165   3              CAN_Tx_Buf[0] = CAN_Rx_Buf[0];
 166   3              CAN_Tx_Buf[1] = CAN_Rx_Buf[1];
 167   3              CAN_Tx_Buf[2] = CP16_ID;
 168   3              CAN_Tx_Buf[3] = FaultCode;
 169   3              CAN_Tx_Buf[4] = 0x01;
 170   3              CAN_Tx_Buf[5] = 0x4a;
 171   3              CAN_Tx_Buf[6] = 0x01;
 172   3              CAN_Tx_Buf[7] = 0x2c;
 173   3            }
 174   2           TxCount++;
 175   2          if(TxCount > 1000 )
 176   2          { 
 177   3            CAN0_TransferMO(IPM_ID);
 178   3            TxCount = 0;
 179   3          }
C51 COMPILER V9.53.0.0   MAIN                                                              06/10/2017 00:58:18 PAGE 4   

 180   2         }
 181   1      }
 182          
 183          //-----------------------------------------------------------------------------
 184          // Initialization Subroutines
 185          //-----------------------------------------------------------------------------
 186          
 187          void OSCILLATOR_Init (void)
 188          {
 189   1         U8 SFRPAGE_save = SFRPAGE;
 190   1         SFRPAGE = CONFIG_PAGE;
 191   1      
 192   1         OSCICN = 0x87;                      // Set internal oscillator divider to 1
 193   1      
 194   1         SFRPAGE = SFRPAGE_save;
 195   1      }
 196          
 197          //-----------------------------------------------------------------------------
 198          // PORT_Init
 199          //-----------------------------------------------------------------------------
 200          
 201          void PORT_Init (void)
 202          {
 203   1        U8 SFRPAGE_save = SFRPAGE;
 204   1         SFRPAGE  = CONFIG_PAGE;             // Port SFR's on Configuration page
 205   1        
 206   1         P0SKIP |= 0x01;                     // Skip P0.0 (VREF)
 207   1         P0MDIN &= ~0x01;                   // Set VREF to analog
 208   1         P0MDOUT  |= 0x40;                   // P0.6 (CAN0 TX) is push-pull
 209   1         P1MDOUT  |= 0x08;                   // P1.3 (LED) is push-pull
 210   1         P1MDOUT &= 0xbf;                   //P1^6 open drain for relay
 211   1         P2SKIP |= 0x0f;                     // Skip P2.0,P2.1,P2.2,P2.3(ADC input)
 212   1         P2MDIN &= ~0x0f;                   // Set P2.0,P2.1,P2.2,P2.3 as an analog input
 213   1         P2MDOUT |= 0xc0;                    //P2.6/7 for driving mosfet
 214   1         P3MDOUT |= 0xff;                            //P3 is push-pull to drive the LED.
 215   1         P4MDOUT |= 0x03;                            //P4   
 216   1      
 217   1         XBR0     = 0x02;                    // Enable CAN0 on Crossbar
 218   1         XBR2     = 0x40;                    // Enable Crossbar and weak pull-ups
 219   1      
 220   1         SFRPAGE = SFRPAGE_save;
 221   1      }
 222          
 223          //-----------------------------------------------------------------------------
 224          // ADC0_Init
 225          //-----------------------------------------------------------------------------
 226          void ADC0_Init(void)
 227          {
 228   1        U8 SFRPAGE_save = SFRPAGE;
 229   1         SFRPAGE = ACTIVE_PAGE;
 230   1      
 231   1         // Initialize the Gain to account for a 5V input and 2.25 VREF
 232   1         // Solve the equation provided in Section 9.3.1 of the Datasheet
 233   1      
 234   1         // The 5V input is scaled by a factor of 0.44 so that the maximum input
 235   1         // voltage seen by the pin is 2.2V
 236   1      
 237   1         // 0.44 = (GAIN/4096) + GAINADD * (1/64)
 238   1      
 239   1         // Set GAIN to 0x6CA and GAINADD to 1
 240   1         // GAIN = is the 12-bit word formed by ADC0GNH[7:0] ADC0GNL[7:4]
 241   1         // GAINADD is bit ADC0GNA.0
C51 COMPILER V9.53.0.0   MAIN                                                              06/10/2017 00:58:18 PAGE 5   

 242   1      
 243   1         ADC0CF |= 0x01;                     // Set GAINEN = 1
 244   1         ADC0H   = 0x04;                     // Load the ADC0GNH address
 245   1         ADC0L   = 0x6C;                     // Load the upper byte of 0x6CA to 
 246   1                                             // ADC0GNH
 247   1         ADC0H   = 0x07;                     // Load the ADC0GNL address
 248   1         ADC0L   = 0xA0;                     // Load the lower nibble of 0x6CA to 
 249   1                                             // ADC0GNL
 250   1         ADC0H   = 0x08;                     // Load the ADC0GNA address
 251   1         ADC0L   = 0x01;                     // Set the GAINADD bit
 252   1         ADC0CF &= ~0x01;                    // Set GAINEN = 0
 253   1      
 254   1         ADC0CN = 0x03;                      // ADC0 disabled, normal tracking,
 255   1                                             // conversion triggered on TMR2 overflow
 256   1                                             // Output is right-justified
 257   1      
 258   1         REF0CN = 0x33;                      // Enable on-chip VREF and buffer
 259   1                                             // Set voltage reference to 2.25V
 260   1      
 261   1         ADC0MX = 0x0A;                      // Set ADC input to P1.2
 262   1      
 263   1         ADC0CF = ((SYSCLK / 3000000) - 1) << 3;   // Set SAR clock to 3MHz
 264   1      
 265   1         EIE1 |= 0x04;                       // Enable ADC0 conversion complete int.
 266   1      
 267   1         AD0EN = 1;                          // Enable ADC0
 268   1      
 269   1         SFRPAGE = SFRPAGE_save;
 270   1      
 271   1      }
 272          
 273          
 274          //-----------------------------------------------------------------------------
 275          // Timer2_Init
 276          //-----------------------------------------------------------------------------
 277          void Timer_Init(void)
 278          {
 279   1       
 280   1         U8 SFRPAGE_save = SFRPAGE;
 281   1         SFRPAGE = ACTIVE_PAGE;
 282   1       
 283   1          CKCON = 0x00;     //t1 t0 use the sys-clock/12,t3 t2 refer to TMRXCN
 284   1          
 285   1         TCON      = 0x00;      //t1 don't run temporarily,t0 don't run 
 286   1         TMOD      = 0x21;      //t1 8bit reload timer,t0 16bit timer
 287   1         TL0       = 0x90;  
 288   1         TH0       = 0xE8;      //3ms,based on 2MHz clock           ×¨ó?óú??DD?D?óê??üá?3ms?¨ê±
 289   1         TR0 = 1;
 290   1         ET0 = 1;
 291   1      
 292   1         TMR2CN = 0x00;                      // Stop Timer2; Clear TF2;
 293   1                                             // use SYSCLK as timebase, 16-bit
 294   1                                             // auto-reload
 295   1         CKCON |= 0x10;                      // Select SYSCLK for timer 2 source
 296   1         TMR2RL = 65535 - (SYSCLK / 10000);  // Init reload value for 10 us
 297   1         TMR2 = 0xFFFF;                      // Set to reload immediately
 298   1         ET2 = 1;                            // Enable Timer2 interrupts
 299   1         TR2 = 1;                            // Start Timer2
 300   1      
 301   1         PT2 = 1;
 302   1      
 303   1          TMR3CN    = 0x00;     //t3 16bit reload timer,don't run,sys-clock/12
C51 COMPILER V9.53.0.0   MAIN                                                              06/10/2017 00:58:18 PAGE 6   

 304   1          //TMR3RL = 20000;
 305   1      ///TMR3 = 0xffff;
 306   1          TMR3RLL   = 0x30;
 307   1          TMR3RLH   = 0xf8;
 308   1          TMR3L     = 0x30;
 309   1          TMR3H     = 0xf8;     //    ó?óúS￡?ms?¨ê± */
 310   1          TMR3CN |= 0x04;       //run timer3
 311   1      
 312   1         SFRPAGE = SFRPAGE_save;
 313   1      }
 314          //-----------------------------------------------------------------------------
 315          // CAN0_Init
 316          //-----------------------------------------------------------------------------
 317          void CAN0_Init (void)
 318          {
 319   1         U8 iter;
 320   1      
 321   1         U8 SFRPAGE_save = SFRPAGE;
 322   1         SFRPAGE  = CAN0_PAGE;               // All CAN register are on page 0x0C
 323   1      
 324   1         CAN0CN |= 0x01;                     // Start Intialization mode
 325   1      
 326   1         //---------Initialize general CAN peripheral settings
 327   1      
 328   1         CAN0CN |= 0x4E;                     // Enable Status, Error,
 329   1                                             // Module Interrupts
 330   1                                             // Enable access to bit timing register
 331   1      
 332   1         // See the CAN Bit Timing Spreadsheet for how to calculate this value
 333   1         CAN0BT = 0x1402;                    // Based on 24 Mhz CAN clock, set the
 334   1                                             // CAN bit rate to 1 Mbps
 335   1      
 336   1         //---------Initialize settings common to all message objects
 337   1      
 338   1         // Command Mask Register
 339   1         CAN0IF1CM = 0x00F0;                 // Write Operation
 340   1                                             // Transfer ID Mask, MDir, MXtd
 341   1                                             // Transfer ID, Dir, Xtd, MsgVal
 342   1                                             // Transfer Control Bits
 343   1                                             // Don't set TxRqst or transfer data
 344   1      
 345   1         // Mask Registers
 346   1         CAN0IF1M1 = 0x0000;                 // Mask Bits 15-0 not used for filtering
 347   1         CAN0IF1M2 = 0x5FFC;                 // Ignore Extended Identifier for
 348   1                                             // filtering
 349   1                                             // Used Direction bit for filtering
 350   1                                             // Use ID bits 28-18 for filtering
 351   1      
 352   1         // Arbitration Registers
 353   1         CAN0IF1A1 = 0x0000;                 // 11-bit ID, so lower 16-bits not used
 354   1      
 355   1         // Message Control Registers
 356   1         CAN0IF1MC = 0x1480 | MESSAGE_SIZE;  // Enable Receive Interrupt
 357   1                                             // Message Object is a Single Message
 358   1                                             // Message Size set by #define
 359   1      
 360   1      
 361   1         //---------Initialize unique settings for Rx message object
 362   1      
 363   1         // Arbitration Registers
 364   1         CAN0IF1A2 = 0x8000 | (CP16_ID << 2);  // Set MsgVal to valid
 365   1                                               // Set Object Direction to read
C51 COMPILER V9.53.0.0   MAIN                                                              06/10/2017 00:58:18 PAGE 7   

 366   1                                               // Set 11-bit Identifier to iter
 367   1      
 368   1         CAN0IF1CR = CP16_ID;                // Start command request
 369   1      
 370   1         while (CAN0IF1CRH & 0x80) {}       // Poll on Busy bit
 371   1      
 372   1         CAN0IF1A2 = 0x8000 | (Broadcast_ID << 2);  // Set MsgVal to valid
 373   1                                               // Set Object Direction to read
 374   1                                               // Set 11-bit Identifier to iter
 375   1      
 376   1         CAN0IF1CR = Broadcast_ID;                // Start command request
 377   1      
 378   1         while (CAN0IF1CRH & 0x80) {}       // Poll on Busy bit
 379   1      
 380   1         // Message Control Registers
 381   1         CAN0IF1MC = 0x0080 | MESSAGE_SIZE;  // Disable Transmit Interrupt
 382   1                                             // Message Object is a Single Message
 383   1                                             // Message Size set by #define
 384   1      
 385   1         //---------Initialize unique settings for Tx message object
 386   1         // Arbitration Registers
 387   1          CAN0IF1A2 = 0xA000 | (CP13_ID << 2);  // Set MsgVal to valid
 388   1                                               // Set Direction to write
 389   1                                               // Set 11-bit Identifier to iter
 390   1      
 391   1         CAN0IF1CR = CP13_ID;                // Start command request
 392   1      
 393   1         while (CAN0IF1CRH & 0x80) {}       // Poll on Busy bit
 394   1      
 395   1         CAN0IF1A2 = 0xA000 | (CP20_ID << 2);  // Set MsgVal to valid
 396   1                                               // Set Direction to write
 397   1                                               // Set 11-bit Identifier to iter
 398   1      
 399   1         CAN0IF1CR = CP20_ID;                // Start command request
 400   1      
 401   1         while (CAN0IF1CRH & 0x80) {}       // Poll on Busy bit
 402   1      
 403   1         CAN0IF1A2 = 0xA000 | (IPM_ID << 2);  // Set MsgVal to valid
 404   1                                               // Set Direction to write
 405   1                                               // Set 11-bit Identifier to iter
 406   1      
 407   1         CAN0IF1CR = IPM_ID;                // Start command request
 408   1      
 409   1         while (CAN0IF1CRH & 0x80) {}       // Poll on Busy bit
 410   1      
 411   1         //---------Initialize settings for unused message objects
 412   1      
 413   1         for (iter = 0; iter < MESSAGE_OBJECTS; iter++)
 414   1         {
 415   2          if(iter != CP20_ID && iter != CP16_ID && iter != Broadcast_ID && iter != IPM_ID && iter != CP13_ID)
 416   2         {
 417   3            // Set remaining message objects to be Ignored
 418   3            CAN0IF1A2 = 0x0000;              // Set MsgVal to 0 to Ignore
 419   3            CAN0IF1CR = iter;                // Start command request
 420   3      
 421   3            while (CAN0IF1CRH & 0x80) {}     // Poll on Busy bit
 422   3          }
 423   2         }
 424   1      
 425   1         CAN0CN &= ~0x41;                    // Return to Normal Mode and disable
 426   1                                             // access to bit timing register
 427   1      
C51 COMPILER V9.53.0.0   MAIN                                                              06/10/2017 00:58:18 PAGE 8   

 428   1         SFRPAGE = SFRPAGE_save;
 429   1      }
 430          
 431          void CAN0_TransferMO (U8 obj_num)
 432          {
 433   1         // This function assumes that the message object is fully initialized
 434   1         // in CAN0_Init and so all it has to do is fill the data registers and
 435   1         // initiate transmission
 436   1      
 437   1         U8 SFRPAGE_save = SFRPAGE;
 438   1         SFRPAGE  = CAN0_PAGE;               // All CAN register are on page 0x0C
 439   1      
 440   1         // Initialize all 8 data bytes even though they might not be sent
 441   1         // The number to send was configured earlier by setting Message Control
 442   1      
 443   1         CAN0IF1DA1L = *CAN_Tx_Buf;              // Initialize data registers based
 444   1         CAN0IF1DA1H = *(CAN_Tx_Buf + 1);          // on message object used
 445   1         CAN0IF1DA2L = *(CAN_Tx_Buf + 2);
 446   1         CAN0IF1DA2H = *(CAN_Tx_Buf + 3);
 447   1         CAN0IF1DB1L = *(CAN_Tx_Buf + 4);
 448   1         CAN0IF1DB1H = *(CAN_Tx_Buf + 5);
 449   1         CAN0IF1DB2L = *(CAN_Tx_Buf + 6);
 450   1         CAN0IF1DB2H = *(CAN_Tx_Buf + 7);
 451   1      
 452   1         CAN0IF1CM = 0x0087;                 // Set Direction to Write
 453   1                                             // Write TxRqst, all 8 data bytes
 454   1      
 455   1         CAN0IF1CR = obj_num;                // Start command request
 456   1      
 457   1         while (CAN0IF1CRH & 0x80) {}        // Poll on Busy bit
 458   1      
 459   1         SFRPAGE = SFRPAGE_save;
 460   1      }
 461          
 462          
 463          //Calculate the pressure detect by ADC
 464          
 465          void PressureCal()
 466          {
 467   1        P_mA_current_ERT=((((( RESULT[1]/4095.0*1000)*1.5*10)/3.0))/250.0);
 468   1        pressure_current_ERT=(int)(62.5*P_mA_current_ERT-243.0);//单位KPa 
 469   1        pressureERT_H=((pressure_current_ERT/1000)<<4)|(pressure_current_ERT%1000/100);
 470   1        pressureERT_L=((pressure_current_ERT%100/10)<<4)|(pressure_current_ERT%10); 
 471   1      
 472   1        P_mA_current_MRT=((((( RESULT[0]/4095.0*1000)*1.5*10)/3.0))/250.0);
 473   1        pressure_current_MRT=(int)(62.5*P_mA_current_MRT-243.0);//单位KPa
 474   1        pressureMRT_H=((pressure_current_MRT/1000)<<4)|(pressure_current_MRT%1000/100);
 475   1        pressureMRT_L=((pressure_current_MRT%100/10)<<4)|(pressure_current_MRT%10);
 476   1      }
 477          
 478          
 479          //Calculate the PID output
 480          void PIDControl()
 481          { 
 482   1        float derror, Uout;
 483   1        error = Target_ERT_Pressure - pressure_current_ERT/100.0;  
 484   1        sumerror += error;
 485   1        derror = error - lasterror;
 486   1        lasterror = error;
 487   1        
 488   1        Uout = kp * error + ki * sumerror + kd * derror;
 489   1        
C51 COMPILER V9.53.0.0   MAIN                                                              06/10/2017 00:58:18 PAGE 9   

 490   1        if(Uout > 0 || Uout == 0)
 491   1        {
 492   2          Uout /= 100.0;
 493   2          PWM_APP = Uout;
 494   2          PWM_REL = 0;
 495   2          if(Uout > 0 && Uout < 0.3)
 496   2            PWM_APP = 0.25;
 497   2          if(Uout > 1)
 498   2            PWM_APP = 1;
 499   2      
 500   2        }
 501   1        else 
 502   1        {
 503   2          PWM_APP = 0;
 504   2          PWM_REL = 0.23;
 505   2        }
 506   1      }
 507          //-----------------------------------------------------------------------------
 508          // Interrupt Service Routines
 509          //-----------------------------------------------------------------------------
 510          
 511          //-----------------------------------------------------------------------------
 512          // CAN0_ISR
 513          //-----------------------------------------------------------------------------
 514          INTERRUPT (CAN0_ISR, INTERRUPT_CAN0)
 515          {
 516   1         U8 carry;
 517   1         UU32 new_data;
 518   1      
 519   1         // SFRPAGE is set to CAN0_Page automatically when ISR starts
 520   1      
 521   1         U8 status = CAN0STAT;               // Read status, which clears the Status
 522   1                                             // Interrupt bit pending in CAN0IID
 523   1      
 524   1         U8 Interrupt_ID = CAN0IID;          // Read which message object caused
 525   1                                             // the interrupt
 526   1         // The CAN0ND registers tell which of the 32 message objects are new.
 527   1         // Read data from CAN registers and perform 1-bit right shift with carry
 528   1         new_data.U8[b0] = CAN0ND1L;         // With a big endian compiler, assign LSB
 529   1         new_data.U8[b1] = CAN0ND1H;
 530   1         new_data.U8[b2] = CAN0ND2L;
 531   1         new_data.U8[b3] = CAN0ND2H;         // Assign MSB
 532   1         carry = new_data.U8[b0] & 0x01;     // Store carry bit
 533   1         new_data.U32 = new_data.U32 >> 1;   // Perform 1-bit shift to realign
 534   1      
 535   1         if (carry)
 536   1         { // Add carry if necessary
 537   2            new_data.U8[b3] = new_data.U8[b3] | 0x80;
 538   2         }
 539   1      
 540   1         // new_data variable will now tell which message object is new.
 541   1      
 542   1         CAN0IF1CM = 0x007F;                 // Read all of message object to IF1
 543   1                                             // Clear IntPnd and newData
 544   1      
 545   1         CAN0IF1CR = Interrupt_ID;           // Start command request
 546   1      
 547   1         while (CAN0IF1CRH & 0x80) {}           // Poll on Busy bit
 548   1      
 549   1         if (status & RxOk )                  // If transmit completed successfully
 550   1         {
 551   2             // Read all 8 data bytes to rxdata, even though they might not be valid
C51 COMPILER V9.53.0.0   MAIN                                                              06/10/2017 00:58:18 PAGE 10  

 552   2            CAN_Rx_Buf[0] = CAN0IF1DA1L;
 553   2            CAN_Rx_Buf[1] = CAN0IF1DA1H;
 554   2            CAN_Rx_Buf[2] = CAN0IF1DA2L;
 555   2            CAN_Rx_Buf[3] = CAN0IF1DA2H;
 556   2            CAN_Rx_Buf[4] = CAN0IF1DB1L;
 557   2            CAN_Rx_Buf[5] = CAN0IF1DB1H;
 558   2            CAN_Rx_Buf[6] = CAN0IF1DB2L;
 559   2            CAN_Rx_Buf[7] = CAN0IF1DB2H;
 560   2            CAN_RX_COMPLETE = 1;
 561   2        if(Interrupt_ID == CP16_ID && CAN_Rx_Buf[2] == BPCP_ID )
 562   2        {
 563   3          Rx_BPCP_OK = 1;
 564   3        }
 565   2        if(Interrupt_ID == Broadcast_ID && CAN_Rx_Buf[2] == IPM_ID )
 566   2        { 
 567   3          if( CAN_Rx_Buf[1] == 0x01 )
 568   3          {
 569   4            switch(CAN_Rx_Buf[0])
 570   4            {
 571   5              case 0x01: Yunzhuanwei(); break;
 572   5              case 0x02: Chuzhiwei(); break;
 573   5              case 0x04: Quanzhidongwei(); break;
 574   5              case 0x08: Yizhiwei(); break;
 575   5              case 0x10: Chonglianwei(); break;
 576   5              case 0x20: Jinjiwei(); break;
 577   5              default:break;
 578   5            }
 579   4          CAN_Tx_Buf[0] = CAN_Rx_Buf[0];
 580   4          CAN_Tx_Buf[1] = CAN_Rx_Buf[1];
 581   4          CAN_Tx_Buf[2] = CP16_ID;
 582   4          CAN_Tx_Buf[3] = FaultCode;
 583   4          CAN_Tx_Buf[4] = pressureERT_H;
 584   4          CAN_Tx_Buf[5] = pressureERT_L;
 585   4          CAN_Tx_Buf[6] = pressureMRT_H;
 586   4          CAN_Tx_Buf[7] = pressureMRT_L;
 587   4      
 588   4          }
 589   3          else if( CAN_Rx_Buf[1] == 0x02)
 590   3          {
 591   4            switch(CAN_Rx_Buf[0])
 592   4            {
 593   5              case 0x04: Ceya();break;
 594   5              default:break;
 595   5            } 
 596   4          CAN_Tx_Buf[0] = CAN_Rx_Buf[0];
 597   4          CAN_Tx_Buf[1] = CAN_Rx_Buf[1];
 598   4          CAN_Tx_Buf[2] = CP16_ID;
 599   4          CAN_Tx_Buf[3] = 0x00;
 600   4          CAN_Tx_Buf[4] = pressureERT_H;
 601   4          CAN_Tx_Buf[5] = pressureERT_L;
 602   4          CAN_Tx_Buf[6] = pressureMRT_H;
 603   4          CAN_Tx_Buf[7] = pressureMRT_L;
 604   4      
 605   4          //CAN0_TransferMO(CP20_ID);
 606   4          CAN0_TransferMO(IPM_ID);
 607   4          }
 608   3      
 609   3          else if ( CAN_Rx_Buf[1] == 0x11)
 610   3          {
 611   4            switch(CAN_Rx_Buf[0])
 612   4            {
 613   5              case 0x01: Yunzhuanwei(); break;
C51 COMPILER V9.53.0.0   MAIN                                                              06/10/2017 00:58:18 PAGE 11  

 614   5              case 0x02: Chuzhiwei(); break;
 615   5              case 0x04: Quanzhidongwei(); break;
 616   5              case 0x08: Yizhiwei(); break;
 617   5              case 0x10: Chonglianwei(); break;
 618   5              case 0x20: Jinjiwei(); break;
 619   5              default:break;
 620   5            }
 621   4            FaultCode = 0x11;
 622   4          CAN_Tx_Buf[0] = CAN_Rx_Buf[0];
 623   4          CAN_Tx_Buf[1] = CAN_Rx_Buf[1];
 624   4          CAN_Tx_Buf[2] = CP16_ID;
 625   4          CAN_Tx_Buf[3] = FaultCode;
 626   4          CAN_Tx_Buf[4] = pressureERT_H;
 627   4          CAN_Tx_Buf[5] = pressureERT_L;
 628   4          CAN_Tx_Buf[6] = pressureMRT_H;
 629   4          CAN_Tx_Buf[7] = pressureMRT_L;
 630   4          CAN0_TransferMO(IPM_ID);
 631   4          }
 632   3        }
 633   2         }
 634   1         // If an error occured, simply update the global variable and continue
 635   1         if (status & LEC)
 636   1         {
 637   2             // The LEC bits identify the type of error, but those are grouped here
 638   2             if ((status & LEC) != 0x07)
 639   2             {
 640   3                CAN_ERROR = 1;
 641   3             }
 642   2         }
 643   1      
 644   1         if (status & BOff)
 645   1         {
 646   2            CAN_ERROR = 1;
 647   2         }
 648   1      
 649   1         if (status & EWarn)
 650   1         {
 651   2            CAN_ERROR = 1;
 652   2         }
 653   1      
 654   1         // Old SFRPAGE is popped off stack when ISR exits
 655   1      }
 656          
 657          
 658          INTERRUPT (TIMER0_ISR, INTERRUPT_TIMER0)
 659          {
 660   1        TF0 = 0;
 661   1        TL0       = 0x90; 
 662   1        TH0       = 0xE8;     //3ms,based on 2MHz clock 
 663   1      
 664   1        PIDControl();
 665   1        
 666   1      }
 667          INTERRUPT (TIMER2_ISR, INTERRUPT_TIMER2)
 668          {
 669   1      
 670   1      //  DisplayNumber(2);
 671   1         TF2H = 0;                           // Reset Interrupt
 672   1            // Set up the AMUX for the next ADC input
 673   1         if (AMUX_INPUT == (ANALOG_INPUTS - 1))
 674   1         {
 675   2            ADC0MX = PIN_TABLE[0] | 0x10;
C51 COMPILER V9.53.0.0   MAIN                                                              06/10/2017 00:58:18 PAGE 12  

 676   2         }
 677   1         else
 678   1         {
 679   2            ADC0MX = PIN_TABLE[AMUX_INPUT+1] | 0x10;
 680   2         }
 681   1         //SendMessageCAN0(EPCU_ERCP_MO,g_uTx_Data1);
 682   1         
 683   1      }
 684          
 685          
 686          INTERRUPT (TIMER3_ISR, INTERRUPT_TIMER3)
 687          {
 688   1        TMR3CN &= 0x7F;//clear flag
 689   1      
 690   1        PWM_APP *= 100;
 691   1        PWM_REL *= 100;
 692   1      
 693   1        PWM_Count++;
 694   1      
 695   1        if(PWM_Count > PWM_Period)
 696   1          PWM_Count = 0;
 697   1      
 698   1        if(PWM_Count < PWM_APP)
 699   1          APP_ON;
 700   1        else 
 701   1          APP_OFF;
 702   1      
 703   1        if(PWM_Count < PWM_REL)
 704   1          REL_ON;
 705   1        else
 706   1          REL_OFF;
 707   1      //  TxCount++;
 708   1      //  if(TxCount>10000 && CAN_Rx_Buf[1] == 0x01)
 709   1      //  {
 710   1      //    TxCount=0;
 711   1      //    CAN_Tx_Buf[0] = CAN_Rx_Buf[0];
 712   1      //    CAN_Tx_Buf[1] = CAN_Rx_Buf[1];
 713   1      //    CAN_Tx_Buf[2] = CP16_ID;
 714   1      //    CAN_Tx_Buf[3] = FaultCode;
 715   1      //    CAN_Tx_Buf[4] = 350>>8&0xff;
 716   1      //    CAN_Tx_Buf[5] = 350&0xff;
 717   1      //    CAN_Tx_Buf[6] = 700>>8&0xff;
 718   1      //    CAN_Tx_Buf[7] = 700&0xff;
 719   1      //    CAN0_TransferMO(IPM_ID);
 720   1      //  }
 721   1      
 722   1      }
 723          
 724          
 725          INTERRUPT (ADC0_ISR, INTERRUPT_ADC0_EOC)
 726          {
 727   1         static U16 int_dec = INT_DEC;       // Integrate/decimate counter
 728   1                                             // A new result is posted when
 729   1                                             // int_dec is 0
 730   1        
 731   1         U8 i;                               // Loop counter
 732   1      
 733   1      
 734   1         AD0INT = 0;                         // Clear ADC conversion complete
 735   1                                             // overflow
 736   1      
 737   1      
C51 COMPILER V9.53.0.0   MAIN                                                              06/10/2017 00:58:18 PAGE 13  

 738   1         accumulator[AMUX_INPUT] += ADC0;    // Read the ADC value and add it to the
 739   1                                             // running total
 740   1      
 741   1         // Reset sample counter <int_dec> and <AMUX_INPUT> if the final input was
 742   1         // just read
 743   1         if(AMUX_INPUT == (ANALOG_INPUTS - 1))
 744   1         {
 745   2            int_dec--;                       // Update decimation counter
 746   2                                             // when the last of the analog inputs
 747   2                                             // is sampled
 748   2      
 749   2            if (int_dec == 0)                // If zero, then post the averaged
 750   2            {                                // results
 751   3               int_dec = INT_DEC;            // Reset counter
 752   3      
 753   3               // Copy each averaged ADC0 value into the RESULT array
 754   3               for(i = 0; i < ANALOG_INPUTS; i++)
 755   3               {
 756   4                  // Copy averaged values into RESULT
 757   4                  RESULT[i] = accumulator[i] / int_dec;
 758   4      
 759   4                  // Reset accumulators
 760   4                  accumulator[i] = 0x00000000;
 761   4               }
 762   3            }
 763   2      
 764   2            AMUX_INPUT = 0;                  // Reset input index back to P0.1
 765   2         }
 766   1         // Otherwise, increment the AMUX channel counter
 767   1         else
 768   1         {
 769   2            AMUX_INPUT++;                    // Step to the next analog mux input
 770   2         }
 771   1         //smg_display(0xe,0xa,0xc,18);
 772   1      }
 773          
 774          
 775          void Yunzhuanwei()
 776          {
 777   1        MV16_ON;
 778   1        if( CAN_Rx_Buf[1] == 0x11 )
 779   1        {
 780   2          MV16_OFF;
 781   2          APP_ON;
 782   2          REL_OFF;
 783   2        }
 784   1        else
 785   1        {
 786   2          APP_OFF;
 787   2          REL_ON;
 788   2        }
 789   1      }
 790          void Chuzhiwei()
 791          {
 792   1        MV16_ON;
 793   1        if( CAN_Rx_Buf[1] == 0x11 )
 794   1        {
 795   2          MV16_OFF;
 796   2        }
 797   1        APP_ON;
 798   1        REL_OFF;
 799   1      }
C51 COMPILER V9.53.0.0   MAIN                                                              06/10/2017 00:58:18 PAGE 14  

 800          
 801          void Quanzhidongwei()
 802          {
 803   1        MV16_ON;
 804   1        if( CAN_Rx_Buf[1] == 0x11 )
 805   1        {
 806   2          MV16_OFF;
 807   2        }
 808   1        APP_ON;
 809   1        REL_OFF;
 810   1      }
 811          
 812          void Yizhiwei()
 813          {
 814   1        MV16_ON;
 815   1        if( CAN_Rx_Buf[1] == 0x11 )
 816   1        {
 817   2          MV16_OFF;
 818   2        }
 819   1        APP_ON;
 820   1        REL_OFF;
 821   1      }
 822          
 823          void Chonglianwei()
 824          {
 825   1        MV16_ON;
 826   1        if( CAN_Rx_Buf[1] == 0x11 )
 827   1        {
 828   2          MV16_OFF;
 829   2        }
 830   1        APP_ON;
 831   1        REL_OFF;
 832   1      }
 833          
 834          void Jinjiwei()
 835          {
 836   1        MV16_ON;
 837   1        if( CAN_Rx_Buf[1] == 0x11 )
 838   1        {
 839   2          MV16_OFF;
 840   2        }
 841   1        APP_ON;
 842   1        REL_OFF;
 843   1      }
 844          
 845          
 846          void Ceya()
 847          {
 848   1        REL_ON;
 849   1      }
 850          //-----------------------------------------------------------------------------
 851          // End Of File
 852          //-----------------------------------------------------------------------------
 853          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2968    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    110      14
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
C51 COMPILER V9.53.0.0   MAIN                                                              06/10/2017 00:58:18 PAGE 15  

   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
