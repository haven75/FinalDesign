C51 COMPILER V9.53.0.0   MAIN                                                              06/03/2017 16:22:16 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: F:\Keil_v5\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          //-----------------------------------------------------------------------------
   2          // Includes
   3          //-----------------------------------------------------------------------------
   4          #include "compiler_defs.h"
   5          #include "C8051F500_defs.h"            // SFR declarations
   6          #include "Display.h"
   7          //-----------------------------------------------------------------------------
   8          // Type Definitions
   9          //-----------------------------------------------------------------------------
  10          
  11          typedef union UU64
  12          {
  13             U32 U32[2];
  14             U16 U16[4];
  15             U8 U8[8];
  16          } UU64;
  17          
  18          //-----------------------------------------------------------------------------
  19          // Function Prototypes
  20          //-----------------------------------------------------------------------------
  21          
  22          void OSCILLATOR_Init (void);
  23          void PORT_Init (void);
  24          void CAN0_Init (void);
  25          void ADC0_Init(void);
  26          void Timer2_Init(void);
  27           
  28          void CAN0_TransferMO (U8 obj_num);
  29          void Yunzhuanwei(void);
  30          void Chuzhiwei(void);
  31          void Quanzhidongwei(void);
  32          void Yizhiwei(void);
  33          void Chonglianwei(void);
  34          void Jinjiwei(void);
  35          void Syunzhuanwei();
  36          void Szhidongwei();
  37          void Ceya();
  38          
  39          INTERRUPT_PROTO (CAN0_ISR, INTERRUPT_CAN0);
  40          INTERRUPT_PROTO (TIMER2_ISR, INTERRUPT_TIMER2);
  41          
  42          //-----------------------------------------------------------------------------
  43          // Global Constants
  44          //-----------------------------------------------------------------------------
  45          
  46          #define SYSCLK       24000000          // System clock speed in Hz
  47          
  48          #define MESSAGE_OBJECTS    32          // Number of message objects to use
  49                                                 // Range is 1-32
  50          #define MESSAGE_SIZE        8          // Size in bytes of each CAN message
  51                                                 // Range is 1-8
  52          
  53          #define RX_COMPLETE_MASK  0xFFFFFFFF   // Set this to (2^MESSAGE_OBJECTS - 1)
  54          
  55          //-----------------------------------------------------------------------------
C51 COMPILER V9.53.0.0   MAIN                                                              06/03/2017 16:22:16 PAGE 2   

  56          // Bit Definition Masks
  57          //-----------------------------------------------------------------------------
  58          
  59          // CAN0STAT
  60          #define BOff  0x80                     // Busoff Status
  61          #define EWarn 0x40                     // Warning Status
  62          #define EPass 0x20                     // Error Passive
  63          #define RxOk  0x10                     // Receive Message Successfully
  64          #define TxOk  0x08                     // Transmitted Message Successfully
  65          #define LEC   0x07                     // Last Error Code
  66          
  67          //-----------------------------------------------------------------------------
  68          // Pin Definitions
  69          //-----------------------------------------------------------------------------
  70          
  71          SBIT (LED, SFR_P1, 3);                 // LED = 1 turns on the LED
  72          
  73          //-----------------------------------------------------------------------------
  74          // Global Variables
  75          //-----------------------------------------------------------------------------
  76          #define IPM_ID 0x001
  77          #define EBV_ID 0x002
  78          #define Broadcast_ID 0x003
  79          #define ERCP_ID 0x010
  80          #define BPCP_ID 0x011
  81          #define CP16_ID 0x012
  82          #define CP20_ID 0x013
  83          #define CP13_ID 0x014
  84          #define TIMER2_RELOAD  200000000
  85          #define ANALOG_INPUTS    4
  86          #define MVLT_ON (P1 &= ~0x40)
  87          #define MVLT_OFF (P1 |= 0x40)
  88          #define APP_ON ( P2 &= ~0x40)
  89          #define APP_OFF (P2 |= 0x40)
  90          #define REL_ON (P2 &= ~0x80)
  91          #define REL_OFF (P2 |= 0x80)
  92          
  93          bit CAN_ERROR = 0;                     // 0 = No Errors occurred
  94                                                 // 1 = Some error(s) occurred
  95          U8 FaultCode = 0x00 ;
  96          
  97          U8 CAN_Tx_Buf[8] = {0xf1, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};
  98          U8 CAN_Rx_Buf[8];
  99          U8 CAN_RX_COMPLETE;       
 100          U8 Rx_Broadcast_OK = 0;           
 101          
 102          U8 PIN_TABLE[ANALOG_INPUTS] = {0x00, 0x01, 0x02, 0x03};
 103          U8 AMUX_INPUT = 0;
 104          
 105          //-----------------------------------------------------------------------------
 106          // MAIN Routine
 107          //-----------------------------------------------------------------------------
 108          
 109          void main (void)
 110          {
 111   1      
 112   1         SFRPAGE = ACTIVE_PAGE;              // Set for PCA0MD
 113   1      
 114   1         PCA0MD &= ~0x40;                    // Disable Watchdog Timer
 115   1      
 116   1         OSCILLATOR_Init ();                 // Initialize oscillator
 117   1         PORT_Init ();                       // Initialize crossbar and GPIO
C51 COMPILER V9.53.0.0   MAIN                                                              06/03/2017 16:22:16 PAGE 3   

 118   1         CAN0_Init ();                       // Start CAN peripheral
 119   1         ADC0_Init ();
 120   1         Timer2_Init ();
 121   1      
 122   1         EIE2 |= 0x02;                       // Enable CAN interupts
 123   1         EA = 1;                             // Enable global interrupts
 124   1         P2 |= 0xC0;
 125   1         while (1)
 126   1         {
 127   2      //      if(Rx_Broadcast_OK)
 128   2      //    {
 129   2      //      CAN0_TransferMO(IPM_ID);
 130   2      //      Rx_Broadcast_OK = 0;
 131   2      //    }
 132   2            smg_display(2, 0, 0xc, 18);
 133   2         }
 134   1      }
 135          
 136          //-----------------------------------------------------------------------------
 137          // Initialization Subroutines
 138          //-----------------------------------------------------------------------------
 139          
 140          void OSCILLATOR_Init (void)
 141          {
 142   1         U8 SFRPAGE_save = SFRPAGE;
 143   1         SFRPAGE = CONFIG_PAGE;
 144   1      
 145   1         OSCICN = 0x87;                      // Set internal oscillator divider to 1
 146   1      
 147   1         SFRPAGE = SFRPAGE_save;
 148   1      }
 149          
 150          //-----------------------------------------------------------------------------
 151          // PORT_Init
 152          //-----------------------------------------------------------------------------
 153          
 154          void PORT_Init (void)
 155          {
 156   1         U8 SFRPAGE_save = SFRPAGE;
 157   1         SFRPAGE  = CONFIG_PAGE;             // Port SFR's on Configuration page
 158   1      
 159   1         P0MDOUT  |= 0x40;                   // P0.6 (CAN0 TX) is push-pull
 160   1         P1MDOUT  |= 0x08;                   // P1.3 (LED) is push-pull
 161   1         P1MDOUT &= 0xbf;                   //P1^6 open drain for relay
 162   1        // P2MDIN |= 0xf0;                     //ADC
 163   1        // P2SKIP |= 0x0f;                     //ADC
 164   1         P2MDOUT |= 0xc0;                    //P2.6/7 for driving mosfet
 165   1         P3MDOUT |= 0xff;                            //P3 is push-pull to drive the LED.
 166   1         P4MDOUT |= 0x03;                            //P4   
 167   1      
 168   1         XBR0     = 0x02;                    // Enable CAN0 on Crossbar
 169   1         XBR2     = 0x40;                    // Enable Crossbar and weak pull-ups
 170   1      
 171   1         SFRPAGE = SFRPAGE_save;
 172   1      }
 173          
 174          //-----------------------------------------------------------------------------
 175          // ADC0_Init
 176          //-----------------------------------------------------------------------------
 177          void ADC0_Init(void)
 178          {
 179   1        U8 SFRPAGE_save = SFRPAGE;
C51 COMPILER V9.53.0.0   MAIN                                                              06/03/2017 16:22:16 PAGE 4   

 180   1        SFRPAGE = ACTIVE_PAGE;
 181   1      
 182   1        ADC0CF |= 0x01;
 183   1        ADC0H = 0x04;
 184   1        ADC0L = 0x6c;
 185   1        ADC0H = 0x07;
 186   1        ADC0L = 0xa0;
 187   1        ADC0H = 0x08;
 188   1        ADC0L = 0x01;
 189   1        ADC0CF &= ~0x01;
 190   1      
 191   1        ADC0CN = 0x10;           //0 start by writing 1 to AD0BUSY, 1 start by overflow of timer 1 , 3 by timer 2
 192   1      
 193   1        REF0CN = 0x33;
 194   1      
 195   1        ADC0MX = 0x10| PIN_TABLE[AMUX_INPUT];
 196   1      
 197   1        ADC0CF = ((SYSCLK /3000000) - 1) << 3;
 198   1      
 199   1      //  EIE1 |= 0x04;
 200   1      
 201   1        AD0EN = 1;
 202   1      
 203   1        SFRPAGE = SFRPAGE_save;
 204   1      
 205   1      }
 206          
 207          
 208          //-----------------------------------------------------------------------------
 209          // Timer2_Init
 210          //-----------------------------------------------------------------------------
 211          void Timer2_Init(void)
 212          {
 213   1         U8 SFRPAGE_save = SFRPAGE;
 214   1         SFRPAGE = ACTIVE_PAGE;
 215   1      
 216   1         CKCON &= ~0x30;                     // Timer2 uses SYSCLK/12
 217   1         TMR2CN &= ~0x01;
 218   1      
 219   1         TMR2RL = TIMER2_RELOAD;             // Reload value to be used in Timer2
 220   1         TMR2 = TMR2RL;                      // Init the Timer2 register
 221   1      
 222   1         TMR2CN = 0x04;                      // Enable Timer2 in auto-reload mode
 223   1         ET2 = 1;                            // Timer2 interrupt enabled
 224   1      
 225   1         SFRPAGE = SFRPAGE_save;
 226   1      }
 227          //-----------------------------------------------------------------------------
 228          // CAN0_Init
 229          //-----------------------------------------------------------------------------
 230          void CAN0_Init (void)
 231          {
 232   1         U8 iter;
 233   1      
 234   1         U8 SFRPAGE_save = SFRPAGE;
 235   1         SFRPAGE  = CAN0_PAGE;               // All CAN register are on page 0x0C
 236   1      
 237   1         CAN0CN |= 0x01;                     // Start Intialization mode
 238   1      
 239   1         //---------Initialize general CAN peripheral settings
 240   1      
 241   1         CAN0CN |= 0x4E;                     // Enable Status, Error,
C51 COMPILER V9.53.0.0   MAIN                                                              06/03/2017 16:22:16 PAGE 5   

 242   1                                             // Module Interrupts
 243   1                                             // Enable access to bit timing register
 244   1      
 245   1         // See the CAN Bit Timing Spreadsheet for how to calculate this value
 246   1         CAN0BT = 0x1402;                    // Based on 24 Mhz CAN clock, set the
 247   1                                             // CAN bit rate to 1 Mbps
 248   1      
 249   1         //---------Initialize settings common to all message objects
 250   1      
 251   1         // Command Mask Register
 252   1         CAN0IF1CM = 0x00F0;                 // Write Operation
 253   1                                             // Transfer ID Mask, MDir, MXtd
 254   1                                             // Transfer ID, Dir, Xtd, MsgVal
 255   1                                             // Transfer Control Bits
 256   1                                             // Don't set TxRqst or transfer data
 257   1      
 258   1         // Mask Registers
 259   1         CAN0IF1M1 = 0x0000;                 // Mask Bits 15-0 not used for filtering
 260   1         CAN0IF1M2 = 0x5FFC;                 // Ignore Extended Identifier for
 261   1                                             // filtering
 262   1                                             // Used Direction bit for filtering
 263   1                                             // Use ID bits 28-18 for filtering
 264   1      
 265   1         // Arbitration Registers
 266   1         CAN0IF1A1 = 0x0000;                 // 11-bit ID, so lower 16-bits not used
 267   1      
 268   1         // Message Control Registers
 269   1         CAN0IF1MC = 0x1480 | MESSAGE_SIZE;  // Enable Receive Interrupt
 270   1                                             // Message Object is a Single Message
 271   1                                             // Message Size set by #define
 272   1      
 273   1      
 274   1         //---------Initialize unique settings for Rx message object
 275   1      
 276   1         // Arbitration Registers
 277   1         CAN0IF1A2 = 0x8000 | (Broadcast_ID << 2);  // Set MsgVal to valid
 278   1                                               // Set Object Direction to read
 279   1                                               // Set 11-bit Identifier to iter
 280   1      
 281   1         CAN0IF1CR = Broadcast_ID;                // Start command request
 282   1      
 283   1            while (CAN0IF1CRH & 0x80) {}       // Poll on Busy bit
 284   1      
 285   1         // Message Control Registers
 286   1         CAN0IF1MC = 0x0080 | MESSAGE_SIZE;  // Disable Transmit Interrupt
 287   1                                             // Message Object is a Single Message
 288   1                                             // Message Size set by #define
 289   1      
 290   1         //---------Initialize unique settings for Tx message object
 291   1         // Arbitration Registers
 292   1         CAN0IF1A2 = 0xA000 | (IPM_ID << 2);  // Set MsgVal to valid
 293   1                                               // Set Direction to write
 294   1                                               // Set 11-bit Identifier to iter
 295   1      
 296   1         CAN0IF1CR = IPM_ID;                // Start command request
 297   1      
 298   1         while (CAN0IF1CRH & 0x80) {}       // Poll on Busy bit
 299   1      
 300   1         //---------Initialize settings for unused message objects
 301   1      
 302   1         for (iter = 0; iter < MESSAGE_OBJECTS; iter++)
 303   1         {
C51 COMPILER V9.53.0.0   MAIN                                                              06/03/2017 16:22:16 PAGE 6   

 304   2          if(iter != Broadcast_ID && iter != IPM_ID)
 305   2         {
 306   3            // Set remaining message objects to be Ignored
 307   3            CAN0IF1A2 = 0x0000;              // Set MsgVal to 0 to Ignore
 308   3            CAN0IF1CR = iter;                // Start command request
 309   3      
 310   3            while (CAN0IF1CRH & 0x80) {}     // Poll on Busy bit
 311   3          }
 312   2         }
 313   1      
 314   1         CAN0CN &= ~0x41;                    // Return to Normal Mode and disable
 315   1                                             // access to bit timing register
 316   1      
 317   1         SFRPAGE = SFRPAGE_save;
 318   1      }
 319          
 320          void CAN0_TransferMO (U8 obj_num)
 321          {
 322   1         // This function assumes that the message object is fully initialized
 323   1         // in CAN0_Init and so all it has to do is fill the data registers and
 324   1         // initiate transmission
 325   1      
 326   1         U8 SFRPAGE_save = SFRPAGE;
 327   1         SFRPAGE  = CAN0_PAGE;               // All CAN register are on page 0x0C
 328   1      
 329   1         // Initialize all 8 data bytes even though they might not be sent
 330   1         // The number to send was configured earlier by setting Message Control
 331   1      
 332   1         CAN0IF1DA1L = *CAN_Tx_Buf;              // Initialize data registers based
 333   1         CAN0IF1DA1H = *(CAN_Tx_Buf + 1);          // on message object used
 334   1         CAN0IF1DA2L = *(CAN_Tx_Buf + 2);
 335   1         CAN0IF1DA2H = *(CAN_Tx_Buf + 3);
 336   1         CAN0IF1DB1L = *(CAN_Tx_Buf + 4);
 337   1         CAN0IF1DB1H = *(CAN_Tx_Buf + 5);
 338   1         CAN0IF1DB2L = *(CAN_Tx_Buf + 6);
 339   1         CAN0IF1DB2H = *(CAN_Tx_Buf + 7);
 340   1      
 341   1         CAN0IF1CM = 0x0087;                 // Set Direction to Write
 342   1                                             // Write TxRqst, all 8 data bytes
 343   1      
 344   1         CAN0IF1CR = obj_num;                // Start command request
 345   1      
 346   1         while (CAN0IF1CRH & 0x80) {}        // Poll on Busy bit
 347   1      
 348   1         SFRPAGE = SFRPAGE_save;
 349   1      }
 350          //-----------------------------------------------------------------------------
 351          // Interrupt Service Routines
 352          //-----------------------------------------------------------------------------
 353          
 354          //-----------------------------------------------------------------------------
 355          // CAN0_ISR
 356          //-----------------------------------------------------------------------------
 357          INTERRUPT (CAN0_ISR, INTERRUPT_CAN0)
 358          {
 359   1         U8 carry;
 360   1         UU32 new_data;
 361   1      
 362   1         // SFRPAGE is set to CAN0_Page automatically when ISR starts
 363   1      
 364   1         U8 status = CAN0STAT;               // Read status, which clears the Status
 365   1                                             // Interrupt bit pending in CAN0IID
C51 COMPILER V9.53.0.0   MAIN                                                              06/03/2017 16:22:16 PAGE 7   

 366   1      
 367   1         U8 Interrupt_ID = CAN0IID;          // Read which message object caused
 368   1                                             // the interrupt
 369   1         // The CAN0ND registers tell which of the 32 message objects are new.
 370   1         // Read data from CAN registers and perform 1-bit right shift with carry
 371   1         new_data.U8[b0] = CAN0ND1L;         // With a big endian compiler, assign LSB
 372   1         new_data.U8[b1] = CAN0ND1H;
 373   1         new_data.U8[b2] = CAN0ND2L;
 374   1         new_data.U8[b3] = CAN0ND2H;         // Assign MSB
 375   1         carry = new_data.U8[b0] & 0x01;     // Store carry bit
 376   1         new_data.U32 = new_data.U32 >> 1;   // Perform 1-bit shift to realign
 377   1      
 378   1         if (carry)
 379   1         { // Add carry if necessary
 380   2            new_data.U8[b3] = new_data.U8[b3] | 0x80;
 381   2         }
 382   1      
 383   1         // new_data variable will now tell which message object is new.
 384   1      
 385   1         CAN0IF1CM = 0x007F;                 // Read all of message object to IF1
 386   1                                             // Clear IntPnd and newData
 387   1      
 388   1         CAN0IF1CR = Interrupt_ID;           // Start command request
 389   1      
 390   1         while (CAN0IF1CRH & 0x80) {}           // Poll on Busy bit
 391   1      
 392   1         if (status & RxOk )                  // If transmit completed successfully
 393   1         {
 394   2             // Read all 8 data bytes to rxdata, even though they might not be valid
 395   2            CAN_Rx_Buf[0] = CAN0IF1DA1L;
 396   2            CAN_Rx_Buf[1] = CAN0IF1DA1H;
 397   2            CAN_Rx_Buf[2] = CAN0IF1DA2L;
 398   2            CAN_Rx_Buf[3] = CAN0IF1DA2H;
 399   2            CAN_Rx_Buf[4] = CAN0IF1DB1L;
 400   2            CAN_Rx_Buf[5] = CAN0IF1DB1H;
 401   2            CAN_Rx_Buf[6] = CAN0IF1DB2L;
 402   2            CAN_Rx_Buf[7] = CAN0IF1DB2H;
 403   2            CAN_RX_COMPLETE = 1;
 404   2      
 405   2        if(Interrupt_ID == Broadcast_ID && CAN_Rx_Buf[2] == IPM_ID)
 406   2        { 
 407   3          if( CAN_Rx_Buf[1] & 0x01 )
 408   3          {
 409   4          //  switch(CAN_Rx_Buf[0])
 410   4          //  {
 411   4          //    case 0x01: Yunzhuanwei(); break;
 412   4          //    case 0x02: Chuzhiwei(); break;
 413   4          //    case 0x04: Quanzhidongwei(); break;
 414   4          //    case 0x08: Yizhiwei(); break;
 415   4          //    case 0x10: Chonglianwei(); break;
 416   4          //    case 0x20: Jinjiwei(); break;
 417   4          //    default:break;
 418   4          //  }
 419   4      //      CAN_Tx_Buf[0] = CAN_Rx_Buf[0];
 420   4      //      CAN_Tx_Buf[1] = CAN_Rx_Buf[1];
 421   4      //      CAN_Tx_Buf[3] = CP20_ID;
 422   4      //      CAN_Tx_Buf[4] = FaultCode;
 423   4      //      Rx_Broadcast_OK = 1;
 424   4          }
 425   3          else if( CAN_Rx_Buf[1] == 0x02)
 426   3          {
 427   4            switch(CAN_Rx_Buf[0])
C51 COMPILER V9.53.0.0   MAIN                                                              06/03/2017 16:22:16 PAGE 8   

 428   4            {
 429   5              case 0x01: Syunzhuanwei();break;
 430   5              case 0x02: Szhidongwei();break;
 431   5              case 0x04: Ceya();break;
 432   5              default:break;
 433   5            } 
 434   4            CAN_Tx_Buf[0] = CAN_Rx_Buf[0];
 435   4            CAN_Tx_Buf[1] = CAN_Rx_Buf[1];
 436   4            CAN_Tx_Buf[2] = CP20_ID;
 437   4            CAN_Tx_Buf[3] = FaultCode;
 438   4        
 439   4            CAN0_TransferMO(IPM_ID);
 440   4          }
 441   3      
 442   3          else if (CAN_Rx_Buf[1] == 0x11)
 443   3          {
 444   4            CAN_Tx_Buf[0] = CAN_Rx_Buf[0];
 445   4            CAN_Tx_Buf[1] = CAN_Rx_Buf[1];
 446   4            CAN_Tx_Buf[2] = CP20_ID;
 447   4            CAN_Tx_Buf[3] = FaultCode;
 448   4          }
 449   3      
 450   3        }
 451   2         }
 452   1         // If an error occured, simply update the global variable and continue
 453   1         if (status & LEC)
 454   1         {
 455   2             // The LEC bits identify the type of error, but those are grouped here
 456   2             if ((status & LEC) != 0x07)
 457   2             {
 458   3                CAN_ERROR = 1;
 459   3             }
 460   2         }
 461   1      
 462   1         if (status & BOff)
 463   1         {
 464   2            CAN_ERROR = 1;
 465   2         }
 466   1      
 467   1         if (status & EWarn)
 468   1         {
 469   2            CAN_ERROR = 1;
 470   2         }
 471   1      
 472   1         // Old SFRPAGE is popped off stack when ISR exits
 473   1      }
 474          
 475          INTERRUPT (TIMER2_ISR, INTERRUPT_TIMER2)
 476          {
 477   1      
 478   1      //  DisplayNumber(2);
 479   1         TF2H = 0;                           // Reset Interrupt
 480   1         
 481   1      }
 482          
 483          
 484          
 485          void Yunzhuanwei()
 486          {
 487   1      
 488   1      }
 489          void Chuzhiwei()
C51 COMPILER V9.53.0.0   MAIN                                                              06/03/2017 16:22:16 PAGE 9   

 490          {
 491   1      
 492   1      }
 493          
 494          void Quanzhidongwei()
 495          {
 496   1      
 497   1      }
 498          
 499          void Yizhiwei()
 500          {
 501   1      
 502   1      }
 503          
 504          void Chonglianwei()
 505          {
 506   1      
 507   1      }
 508          
 509          void Jinjiwei()
 510          {
 511   1        
 512   1      
 513   1      }
 514          
 515          void Syunzhuanwei()
 516          {
 517   1        MVLT_ON;
 518   1        APP_OFF;
 519   1        REL_ON;
 520   1      }
 521          
 522          void Szhidongwei()
 523          {
 524   1        MVLT_ON;
 525   1        APP_ON;
 526   1        REL_OFF;
 527   1      }
 528          
 529          void Ceya()
 530          {
 531   1        MVLT_ON;
 532   1        APP_OFF;
 533   1        REL_OFF;
 534   1      }
 535          //-----------------------------------------------------------------------------
 536          // End Of File
 537          //-----------------------------------------------------------------------------
 538          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    761    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     24       5
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
