C51 COMPILER V9.53.0.0   MAIN                                                              06/03/2017 16:28:17 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: F:\Keil_v5\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          //-----------------------------------------------------------------------------
   2          // Includes
   3          //-----------------------------------------------------------------------------
   4          #include "compiler_defs.h"
   5          #include "C8051F500_defs.h"            // SFR declarations
   6          #include "Display.h"
   7          
   8          //-----------------------------------------------------------------------------
   9          // Type Definitions
  10          //-----------------------------------------------------------------------------
  11          
  12          typedef union UU64
  13          {
  14             U32 U32[2];
  15             U16 U16[4];
  16             U8 U8[8];
  17          } UU64;
  18          
  19          //-----------------------------------------------------------------------------
  20          // Function Prototypes
  21          //-----------------------------------------------------------------------------
  22          
  23          void OSCILLATOR_Init (void);
  24          void PORT_Init (void);
  25          void CAN0_Init (void);
  26          void ADC0_Init(void);
  27          void Timer_Init(void);
  28          void CAN0_TransferMO (U8 obj_num);
  29          
  30          void PressureCal();
  31          void PIDControl();
  32          
  33          
  34          
  35          void Yunzhuanwei(void);
  36          void Chuzhiwei(void);
  37          void Quanzhidongwei(void);
  38          void Yizhiwei(void);
  39          void Chonglianwei(void);
  40          void Jinjiwei(void);
  41          
  42          INTERRUPT_PROTO (CAN0_ISR, INTERRUPT_CAN0);
  43          INTERRUPT_PROTO (TIMER0_ISR, INTERRUPT_TIMER0);
  44          INTERRUPT_PROTO (TIMER2_ISR, INTERRUPT_TIMER2);
  45          //INTERRUPT_PROTO (TIMER3_ISR, INTERRUPT_TIMER3);
  46          INTERRUPT_PROTO (ADC0_ISR, INTERRUPT_ADC0_EOC);
  47          
  48          //-----------------------------------------------------------------------------
  49          // Global Constants
  50          //-----------------------------------------------------------------------------
  51          #define SYSCLK       24000000          // System clock speed in Hz
  52          #define MESSAGE_OBJECTS    32          // Number of message objects to use
  53                                                 // Range is 1-32
  54          #define MESSAGE_SIZE        8          // Size in bytes of each CAN message
  55                                                 // Range is 1-8
C51 COMPILER V9.53.0.0   MAIN                                                              06/03/2017 16:28:17 PAGE 2   

  56          
  57          //-----------------------------------------------------------------------------
  58          // Bit Definition Masks
  59          //-----------------------------------------------------------------------------
  60          
  61          // CAN0STAT
  62          #define BOff  0x80                     // Busoff Status
  63          #define EWarn 0x40                     // Warning Status
  64          #define EPass 0x20                     // Error Passive
  65          #define RxOk  0x10                     // Receive Message Successfully
  66          #define TxOk  0x08                     // Transmitted Message Successfully
  67          #define LEC   0x07                     // Last Error Code
  68          
  69          
  70          #define MV53_ON (P1 &= ~0x40)
  71          #define MV53_OFF (P1 |= 0x40)
  72          #define MVEM_ON ( P2 &= ~0x40)
  73          #define MVEM_OFF (P2 |= 0x40)
  74          #define EMV_ON (P2 &= ~0x80)
  75          #define EMV_OFF (P2 |= 0x80)
  76          
  77          //-----------------------------------------------------------------------------
  78          // Global Variables
  79          //-----------------------------------------------------------------------------
  80          #define IPM_ID 0x001
  81          #define EBV_ID 0x002
  82          #define Broadcast_ID 0x003
  83          #define ERCP_ID 0x010
  84          #define BPCP_ID 0x011
  85          #define CP16_ID 0x012
  86          #define Respond_ID 0x25
  87          #define ANALOG_INPUTS    2
  88          #define INT_DEC             256        // Integrate and decimate ratio
  89          
  90          
  91          bit CAN_ERROR = 0;                     // 0 = No Errors occurred
  92                                                 // 1 = Some error(s) occurred
  93          U8 FaultCode = 0x00;
  94          
  95          U8 CAN_Tx_Buf[8] = {0xf1, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};
  96          U8 CAN_Rx_Buf[8];
  97          U8 CAN_RX_COMPLETE;               
  98          bit Rx_ERCP_OK ;
  99          
 100          SEGMENT_VARIABLE (RESULT[ANALOG_INPUTS], U32, xdata);
 101          U8 PIN_TABLE[ANALOG_INPUTS] = {0x00, 0x01};
 102          U32 accumulator[ANALOG_INPUTS];
 103          U8 AMUX_INPUT = 0;
 104          U8 PWM_Count = 0;
 105          U8 PWM_Period = 100;
 106          U8 PWM_APP = 0;
 107          U8 PWM_REL = 0;
 108          
 109          U32 Target_ERT_Pressure  ;
 110          
 111          U32 pressure_current_ERT;
 112          U16 pressureERT_H;
 113          U16 pressureERT_L;
 114          float P_mA_current_ERT=0 ;
 115          
 116          
 117          U32 pressure_current_MRT;
C51 COMPILER V9.53.0.0   MAIN                                                              06/03/2017 16:28:17 PAGE 3   

 118          U16 pressureMRT_H;
 119          U16 pressureMRT_L;
 120          float P_mA_current_MRT=0 ;
 121          
 122          float error, sumerror, lasterror, kp, ki, kd;
 123          //-----------------------------------------------------------------------------
 124          // MAIN Routine
 125          //-----------------------------------------------------------------------------
 126          
 127          void main (void)
 128          {
 129   1      
 130   1         SFRPAGE = ACTIVE_PAGE;              // Set for PCA0MD
 131   1      
 132   1         PCA0MD &= ~0x40;                    // Disable Watchdog Timer
 133   1      
 134   1         OSCILLATOR_Init ();                 // Initialize oscillator
 135   1         PORT_Init ();                       // Initialize crossbar and GPIO
 136   1         CAN0_Init ();                       // Start CAN peripheral
 137   1         ADC0_Init ();
 138   1         Timer_Init ();
 139   1         RESULT[0]=0;
 140   1         RESULT[1]=0;
 141   1      
 142   1         //EIE1 |= 0x40;
 143   1         EIE2 |= 0x02;                       // Enable CAN interupts
 144   1         EA = 1;                             // Enable global interrupts
 145   1         P2 |= 0xC0;
 146   1         while (1)
 147   1         {
 148   2           smg_display(0xb,18,0xc,18);
 149   2           PressureCal();
 150   2           if(Rx_ERCP_OK)
 151   2            {
 152   3              CAN0_TransferMO(IPM_ID);
 153   3              Rx_ERCP_OK = 0;
 154   3              CAN0_TransferMO (CP16_ID);
 155   3            }
 156   2        }
 157   1      }
 158          
 159          
 160          
 161          void OSCILLATOR_Init (void)
 162          {
 163   1         U8 SFRPAGE_save = SFRPAGE;
 164   1         SFRPAGE = CONFIG_PAGE;
 165   1      
 166   1         OSCICN = 0x87;                      // Set internal oscillator divider to 1
 167   1      
 168   1         SFRPAGE = SFRPAGE_save;
 169   1      }
 170          
 171          //-----------------------------------------------------------------------------
 172          // PORT_Init
 173          //-----------------------------------------------------------------------------
 174          
 175          void PORT_Init (void)
 176          {
 177   1         U8 SFRPAGE_save = SFRPAGE;
 178   1         SFRPAGE  = CONFIG_PAGE;             // Port SFR's on Configuration page
 179   1        
C51 COMPILER V9.53.0.0   MAIN                                                              06/03/2017 16:28:17 PAGE 4   

 180   1         P0SKIP |= 0x01;                     // Skip P0.0 (VREF)
 181   1         P0MDIN &= ~0x01;                   // Set VREF to analog
 182   1         P0MDOUT  |= 0x40;                   // P0.6 (CAN0 TX) is push-pull
 183   1         P1MDOUT  |= 0x08;                   // P1.3 (LED) is push-pull
 184   1         P1MDOUT &= 0xbf;                   //P1^6 open drain for relay
 185   1         P2SKIP |= 0x0f;                     // Skip P2.0,P2.1,P2.2,P2.3(ADC input)
 186   1         P2MDIN &= ~0x0f;                   // Set P2.0,P2.1,P2.2,P2.3 as an analog input
 187   1         P2MDOUT |= 0xc0;                    //P2.6/7 for driving mosfet
 188   1         P3MDOUT |= 0xff;                            //P3 is push-pull to drive the LED.
 189   1         P4MDOUT |= 0x03;                            //P4   
 190   1      
 191   1         XBR0     = 0x02;                    // Enable CAN0 on Crossbar
 192   1         XBR2     = 0x40;                    // Enable Crossbar and weak pull-ups
 193   1      
 194   1         SFRPAGE = SFRPAGE_save;
 195   1      }
 196          
 197          //-----------------------------------------------------------------------------
 198          // ADC0_Init
 199          //-----------------------------------------------------------------------------
 200          void ADC0_Init (void)
 201          {
 202   1         U8 SFRPAGE_save = SFRPAGE;
 203   1         SFRPAGE = ACTIVE_PAGE;
 204   1      
 205   1         // Initialize the Gain to account for a 5V input and 2.25 VREF
 206   1         // Solve the equation provided in Section 9.3.1 of the Datasheet
 207   1      
 208   1         // The 5V input is scaled by a factor of 0.44 so that the maximum input
 209   1         // voltage seen by the pin is 2.2V
 210   1      
 211   1         // 0.44 = (GAIN/4096) + GAINADD * (1/64)
 212   1      
 213   1         // Set GAIN to 0x6CA and GAINADD to 1
 214   1         // GAIN = is the 12-bit word formed by ADC0GNH[7:0] ADC0GNL[7:4]
 215   1         // GAINADD is bit ADC0GNA.0
 216   1      
 217   1         ADC0CF |= 0x01;                     // Set GAINEN = 1
 218   1         ADC0H   = 0x04;                     // Load the ADC0GNH address
 219   1         ADC0L   = 0x6C;                     // Load the upper byte of 0x6CA to 
 220   1                                             // ADC0GNH
 221   1         ADC0H   = 0x07;                     // Load the ADC0GNL address
 222   1         ADC0L   = 0xA0;                     // Load the lower nibble of 0x6CA to 
 223   1                                             // ADC0GNL
 224   1         ADC0H   = 0x08;                     // Load the ADC0GNA address
 225   1         ADC0L   = 0x01;                     // Set the GAINADD bit
 226   1         ADC0CF &= ~0x01;                    // Set GAINEN = 0
 227   1      
 228   1         ADC0CN = 0x03;                      // ADC0 disabled, normal tracking,
 229   1                                             // conversion triggered on TMR2 overflow
 230   1                                             // Output is right-justified
 231   1      
 232   1         REF0CN = 0x33;                      // Enable on-chip VREF and buffer
 233   1                                             // Set voltage reference to 2.25V
 234   1      
 235   1         ADC0MX = 0x0A;                      // Set ADC input to P1.2
 236   1      
 237   1         ADC0CF = ((SYSCLK / 3000000) - 1) << 3;   // Set SAR clock to 3MHz
 238   1      
 239   1         EIE1 |= 0x04;                       // Enable ADC0 conversion complete int.
 240   1      
 241   1         AD0EN = 1;                          // Enable ADC0
C51 COMPILER V9.53.0.0   MAIN                                                              06/03/2017 16:28:17 PAGE 5   

 242   1      
 243   1         SFRPAGE = SFRPAGE_save;
 244   1      }
 245          
 246          
 247          //-----------------------------------------------------------------------------
 248          // Timer2_Init
 249          //-----------------------------------------------------------------------------
 250          void Timer_Init(void)
 251          {
 252   1         U8 SFRPAGE_save = SFRPAGE;
 253   1         SFRPAGE = ACTIVE_PAGE;
 254   1       
 255   1          CKCON = 0x00;     //t1 t0 use the sys-clock/12,t3 t2 refer to TMRXCN
 256   1          
 257   1         TCON      = 0x00;      //t1 don't run temporarily,t0 don't run 
 258   1         TMOD      = 0x21;      //t1 8bit reload timer,t0 16bit timer
 259   1         TL0       = 0x90;  
 260   1         TH0       = 0xE8;      //3ms,based on 2MHz clock           ×¨ó?óú??DD?D?óê??üá?3ms?¨ê±
 261   1         TR0 = 1;
 262   1         ET0 = 1;
 263   1      
 264   1         TMR2CN = 0x00;                      // Stop Timer2; Clear TF2;
 265   1                                             // use SYSCLK as timebase, 16-bit
 266   1                                             // auto-reload
 267   1         CKCON |= 0x10;                      // Select SYSCLK for timer 2 source
 268   1         TMR2RL = 65535 - (SYSCLK / 10000);  // Init reload value for 10 us
 269   1         TMR2 = 0xFFFF;                      // Set to reload immediately
 270   1         ET2 = 1;                            // Enable Timer2 interrupts
 271   1         TR2 = 1;                            // Start Timer2
 272   1      
 273   1         PT2 = 1;
 274   1      
 275   1          TMR3CN    = 0x00;     //t3 16bit reload timer,don't run,sys-clock/12
 276   1          //TMR3RL = 20000;
 277   1      ///TMR3 = 0xffff;
 278   1        TMR3RLL   = 0x30;
 279   1          TMR3RLH   = 0xf8;
 280   1          TMR3L     = 0x30;
 281   1          TMR3H     = 0xf8;     //    ó?óúS￡?ms?¨ê± */
 282   1        TMR3CN |= 0x04;       //run timer3
 283   1      
 284   1         SFRPAGE = SFRPAGE_save;
 285   1      }
 286          //-----------------------------------------------------------------------------
 287          // CAN0_Init
 288          //-----------------------------------------------------------------------------
 289          void CAN0_Init (void)
 290          {
 291   1         U8 iter;
 292   1      
 293   1         U8 SFRPAGE_save = SFRPAGE;
 294   1         SFRPAGE  = CAN0_PAGE;               // All CAN register are on page 0x0C
 295   1      
 296   1         CAN0CN |= 0x01;                     // Start Intialization mode
 297   1      
 298   1         //---------Initialize general CAN peripheral settings
 299   1      
 300   1         CAN0CN |= 0x4E;                     // Enable Status, Error,
 301   1                                             // Module Interrupts
 302   1                                             // Enable access to bit timing register
 303   1      
C51 COMPILER V9.53.0.0   MAIN                                                              06/03/2017 16:28:17 PAGE 6   

 304   1         // See the CAN Bit Timing Spreadsheet for how to calculate this value
 305   1         CAN0BT = 0x1402;                    // Based on 24 Mhz CAN clock, set the
 306   1                                             // CAN bit rate to 1 Mbps
 307   1      
 308   1         //---------Initialize settings common to all message objects
 309   1      
 310   1         // Command Mask Register
 311   1         CAN0IF1CM = 0x00F0;                 // Write Operation
 312   1                                             // Transfer ID Mask, MDir, MXtd
 313   1                                             // Transfer ID, Dir, Xtd, MsgVal
 314   1                                             // Transfer Control Bits
 315   1                                             // Don't set TxRqst or transfer data
 316   1      
 317   1         // Mask Registers
 318   1         CAN0IF1M1 = 0x0000;                 // Mask Bits 15-0 not used for filtering
 319   1         CAN0IF1M2 = 0x5FFC;                 // Ignore Extended Identifier for
 320   1                                             // filtering
 321   1                                             // Used Direction bit for filtering
 322   1                                             // Use ID bits 28-18 for filtering
 323   1      
 324   1         // Arbitration Registers
 325   1         CAN0IF1A1 = 0x0000;                 // 11-bit ID, so lower 16-bits not used
 326   1      
 327   1         // Message Control Registers
 328   1         CAN0IF1MC = 0x1480 | MESSAGE_SIZE;  // Enable Receive Interrupt
 329   1                                             // Message Object is a Single Message
 330   1                                             // Message Size set by #define
 331   1      
 332   1      
 333   1         //---------Initialize unique settings for Rx message object
 334   1      
 335   1         // Arbitration Registers
 336   1         CAN0IF1A2 = 0x8000 | (BPCP_ID << 2);  // Set MsgVal to valid
 337   1                                               // Set Object Direction to read
 338   1                                               // Set 11-bit Identifier to iter
 339   1      
 340   1         CAN0IF1CR = BPCP_ID;                // Start command request
 341   1      
 342   1            while (CAN0IF1CRH & 0x80) {}       // Poll on Busy bit
 343   1      
 344   1      
 345   1         CAN0IF1A2 = 0x8000 | (Broadcast_ID << 2);  // Set MsgVal to valid
 346   1                                               // Set Object Direction to read
 347   1                                               // Set 11-bit Identifier to iter
 348   1      
 349   1         CAN0IF1CR = Broadcast_ID;                // Start command request
 350   1      
 351   1            while (CAN0IF1CRH & 0x80) {}       // Poll on Busy bit
 352   1         // Message Control Registers
 353   1         CAN0IF1MC = 0x0080 | MESSAGE_SIZE;  // Disable Transmit Interrupt
 354   1                                             // Message Object is a Single Message
 355   1                                             // Message Size set by #define
 356   1      
 357   1         //---------Initialize unique settings for Tx message object
 358   1         // Arbitration Registers
 359   1         CAN0IF1A2 = 0xA000 | (IPM_ID << 2);  // Set MsgVal to valid
 360   1                                               // Set Direction to write
 361   1                                               // Set 11-bit Identifier to iter
 362   1      
 363   1         CAN0IF1CR = IPM_ID;                // Start command request
 364   1      
 365   1         while (CAN0IF1CRH & 0x80) {}       // Poll on Busy bit
C51 COMPILER V9.53.0.0   MAIN                                                              06/03/2017 16:28:17 PAGE 7   

 366   1      
 367   1         CAN0IF1A2 = 0xA000 | (CP16_ID << 2);  // Set MsgVal to valid
 368   1                                               // Set Direction to write
 369   1                                               // Set 11-bit Identifier to iter
 370   1      
 371   1         CAN0IF1CR = CP16_ID;                // Start command request
 372   1      
 373   1         while (CAN0IF1CRH & 0x80) {}       // Poll on Busy bit
 374   1         //---------Initialize settings for unused message objects
 375   1      
 376   1         for (iter = 0; iter < MESSAGE_OBJECTS; iter++)
 377   1         {
 378   2          if(iter != CP16_ID && iter != BPCP_ID && iter != Broadcast_ID && iter != IPM_ID)
 379   2         {
 380   3            // Set remaining message objects to be Ignored
 381   3            CAN0IF1A2 = 0x0000;              // Set MsgVal to 0 to Ignore
 382   3            CAN0IF1CR = iter;                // Start command request
 383   3      
 384   3            while (CAN0IF1CRH & 0x80) {}     // Poll on Busy bit
 385   3          }
 386   2         }
 387   1      
 388   1         CAN0CN &= ~0x41;                    // Return to Normal Mode and disable
 389   1                                             // access to bit timing register
 390   1      
 391   1         SFRPAGE = SFRPAGE_save;
 392   1      }
 393          
 394          void CAN0_TransferMO (U8 obj_num)
 395          {
 396   1         // This function assumes that the message object is fully initialized
 397   1         // in CAN0_Init and so all it has to do is fill the data registers and
 398   1         // initiate transmission
 399   1      
 400   1         U8 SFRPAGE_save = SFRPAGE;
 401   1         SFRPAGE  = CAN0_PAGE;               // All CAN register are on page 0x0C
 402   1      
 403   1         // Initialize all 8 data bytes even though they might not be sent
 404   1         // The number to send was configured earlier by setting Message Control
 405   1      
 406   1         CAN0IF1DA1L = *CAN_Tx_Buf;              // Initialize data registers based
 407   1         CAN0IF1DA1H = *(CAN_Tx_Buf + 1);          // on message object used
 408   1         CAN0IF1DA2L = *(CAN_Tx_Buf + 2);
 409   1         CAN0IF1DA2H = *(CAN_Tx_Buf + 3);
 410   1         CAN0IF1DB1L = *(CAN_Tx_Buf + 4);
 411   1         CAN0IF1DB1H = *(CAN_Tx_Buf + 5);
 412   1         CAN0IF1DB2L = *(CAN_Tx_Buf + 6);
 413   1         CAN0IF1DB2H = *(CAN_Tx_Buf + 7);
 414   1      
 415   1         CAN0IF1CM = 0x0087;                 // Set Direction to Write
 416   1                                             // Write TxRqst, all 8 data bytes
 417   1      
 418   1         CAN0IF1CR = obj_num;                // Start command request
 419   1      
 420   1         while (CAN0IF1CRH & 0x80) {}        // Poll on Busy bit
 421   1      
 422   1         SFRPAGE = SFRPAGE_save;
 423   1      }
 424          
 425          //Calculate the pressure detect by ADC
 426          
 427          void PressureCal()
C51 COMPILER V9.53.0.0   MAIN                                                              06/03/2017 16:28:17 PAGE 8   

 428          {
 429   1        P_mA_current_ERT=((((( RESULT[1] / 4095.0 * 1000) * 1.5 * 10) / 3.0)) / 250.0);
 430   1        pressure_current_ERT=(int)(62.5 * P_mA_current_ERT - 243.0);//单位KPa 
 431   1        pressureERT_H=((pressure_current_ERT / 1000) << 4)|(pressure_current_ERT % 1000 / 100);
 432   1        pressureERT_L=((pressure_current_ERT % 100 / 10) << 4) | (pressure_current_ERT  % 10);  
 433   1      
 434   1        P_mA_current_MRT=((((( RESULT[0] / 4095.0 * 1000) * 1.5 * 10) / 3.0)) / 250.0);
 435   1        pressure_current_MRT=(int)(62.5 * P_mA_current_MRT - 243.0);//单位KPa
 436   1        pressureMRT_H=((pressure_current_MRT / 1000) << 4)|(pressure_current_MRT % 1000 / 100);
 437   1        pressureMRT_L=((pressure_current_MRT % 100 / 10) << 4)|(pressure_current_MRT % 10);
 438   1      }
 439          
 440          
 441          //Calculate the PID output
 442          void PIDControl()
 443          { 
 444   1        float derror, Uout;
 445   1        error = Target_ERT_Pressure - pressure_current_ERT/100.0;  
 446   1        sumerror += error;
 447   1        derror = error - lasterror;
 448   1        lasterror = error;
 449   1        
 450   1        Uout = kp * error + ki * sumerror + kd * derror;
 451   1        
 452   1        if(Uout > 0 || Uout == 0)
 453   1        {
 454   2          Uout /= 100.0;
 455   2          PWM_APP = Uout;
 456   2          PWM_REL = 0;
 457   2          if(Uout > 0 && Uout < 0.3)
 458   2            PWM_APP = 0.25;
 459   2          if(Uout > 1)
 460   2            PWM_APP = 1;
 461   2      
 462   2        }
 463   1        else 
 464   1        {
 465   2          PWM_APP = 0;
 466   2          PWM_REL = 0.23;
 467   2        }
 468   1      
 469   1      
 470   1      
 471   1      }
 472          //-----------------------------------------------------------------------------
 473          // Interrupt Service Routines
 474          //-----------------------------------------------------------------------------
 475          
 476          //-----------------------------------------------------------------------------
 477          // CAN0_ISR
 478          //-----------------------------------------------------------------------------
 479          INTERRUPT (CAN0_ISR, INTERRUPT_CAN0)
 480          {
 481   1         U8 carry;
 482   1         UU32 new_data;
 483   1      
 484   1         // SFRPAGE is set to CAN0_Page automatically when ISR starts
 485   1      
 486   1         U8 status = CAN0STAT;               // Read status, which clears the Status
 487   1                                             // Interrupt bit pending in CAN0IID
 488   1      
 489   1         U8 Interrupt_ID = CAN0IID;          // Read which message object caused
C51 COMPILER V9.53.0.0   MAIN                                                              06/03/2017 16:28:17 PAGE 9   

 490   1                                             // the interrupt
 491   1         // The CAN0ND registers tell which of the 32 message objects are new.
 492   1         // Read data from CAN registers and perform 1-bit right shift with carry
 493   1         new_data.U8[b0] = CAN0ND1L;         // With a big endian compiler, assign LSB
 494   1         new_data.U8[b1] = CAN0ND1H;
 495   1         new_data.U8[b2] = CAN0ND2L;
 496   1         new_data.U8[b3] = CAN0ND2H;         // Assign MSB
 497   1         carry = new_data.U8[b0] & 0x01;     // Store carry bit
 498   1         new_data.U32 = new_data.U32 >> 1;   // Perform 1-bit shift to realign
 499   1      
 500   1         if (carry)
 501   1         { // Add carry if necessary
 502   2            new_data.U8[b3] = new_data.U8[b3] | 0x80;
 503   2         }
 504   1      
 505   1         // new_data variable will now tell which message object is new.
 506   1      
 507   1         CAN0IF1CM = 0x007F;                 // Read all of message object to IF1
 508   1                                             // Clear IntPnd and newData
 509   1      
 510   1         CAN0IF1CR = Interrupt_ID;           // Start command request
 511   1      
 512   1         while (CAN0IF1CRH & 0x80) {}           // Poll on Busy bit
 513   1      
 514   1         if (status & RxOk )                  // If transmit completed successfully
 515   1         {
 516   2             // Read all 8 data bytes to rxdata, even though they might not be valid
 517   2            CAN_Rx_Buf[0] = CAN0IF1DA1L;
 518   2            CAN_Rx_Buf[1] = CAN0IF1DA1H;
 519   2            CAN_Rx_Buf[2] = CAN0IF1DA2L;
 520   2            CAN_Rx_Buf[3] = CAN0IF1DA2H;
 521   2            CAN_Rx_Buf[4] = CAN0IF1DB1L;
 522   2            CAN_Rx_Buf[5] = CAN0IF1DB1H;
 523   2            CAN_Rx_Buf[6] = CAN0IF1DB2L;
 524   2            CAN_Rx_Buf[7] = CAN0IF1DB2H;
 525   2            CAN_RX_COMPLETE = 1;
 526   2        
 527   2           if(Interrupt_ID == BPCP_ID && CAN_Rx_Buf[2] == ERCP_ID && CAN_Rx_Buf[3] == 0x00)
 528   2          {
 529   3            Rx_ERCP_OK = 1;
 530   3          }
 531   2          if(Interrupt_ID == Broadcast_ID  && CAN_Rx_Buf[2] == IPM_ID)
 532   2          {
 533   3            if( CAN_Rx_Buf[1] == 0x01)
 534   3            {
 535   4              switch(CAN_Rx_Buf[0])
 536   4              {
 537   5                case 0x01: Yunzhuanwei(); break;
 538   5                case 0x02: Chuzhiwei(); break;
 539   5                case 0x04: Quanzhidongwei(); break;
 540   5                case 0x08: Yizhiwei(); break;
 541   5                case 0x10: Chonglianwei(); break;
 542   5                case 0x20: Jinjiwei(); break;
 543   5                default:break;
 544   5              }
 545   4          
 546   4              CAN_Tx_Buf[0] = CAN_Rx_Buf[0];
 547   4              CAN_Tx_Buf[1] = CAN_Rx_Buf[1];
 548   4              CAN_Tx_Buf[2] = BPCP_ID;
 549   4              CAN_Tx_Buf[3] = FaultCode;
 550   4              CAN_Tx_Buf[4] = pressureERT_H;
 551   4              CAN_Tx_Buf[5] = pressureERT_L;
C51 COMPILER V9.53.0.0   MAIN                                                              06/03/2017 16:28:17 PAGE 10  

 552   4              CAN_Tx_Buf[6] = pressureMRT_H;
 553   4              CAN_Tx_Buf[7] = pressureMRT_L;
 554   4              //CAN0_TransferMO(Respond_ID);
 555   4            }
 556   3            else if (CAN_Rx_Buf[1] == 0x11)
 557   3            {
 558   4              switch(CAN_Rx_Buf[0])
 559   4              {
 560   5                case 0x01: Yunzhuanwei(); break;
 561   5                case 0x02: Chuzhiwei(); break;
 562   5                case 0x04: Quanzhidongwei(); break;
 563   5                case 0x08: Yizhiwei(); break;
 564   5                case 0x10: Chonglianwei(); break;
 565   5                case 0x20: Jinjiwei(); break;
 566   5                default:break;
 567   5              }
 568   4          
 569   4              CAN_Tx_Buf[0] = CAN_Rx_Buf[0];
 570   4              CAN_Tx_Buf[1] = CAN_Rx_Buf[1];
 571   4              CAN_Tx_Buf[2] = BPCP_ID;
 572   4              CAN_Tx_Buf[3] = FaultCode;
 573   4              CAN_Tx_Buf[4] = pressureERT_H;
 574   4              CAN_Tx_Buf[5] = pressureERT_L;
 575   4              CAN_Tx_Buf[6] = pressureMRT_H;
 576   4              CAN_Tx_Buf[7] = pressureMRT_L;
 577   4              //CAN0_TransferMO(Respond_ID);
 578   4              CAN0_TransferMO(IPM_ID);
 579   4              //CAN0_TransferMO (CP16_ID);
 580   4            }
 581   3          }
 582   2         }
 583   1         // If an error occured, simply update the global variable and continue
 584   1         if (status & LEC)
 585   1         {
 586   2             // The LEC bits identify the type of error, but those are grouped here
 587   2             if ((status & LEC) != 0x07)
 588   2             {
 589   3                CAN_ERROR = 1;
 590   3             }
 591   2         }
 592   1      
 593   1         if (status & BOff)
 594   1         {
 595   2            CAN_ERROR = 1;
 596   2         }
 597   1      
 598   1         if (status & EWarn)
 599   1         {
 600   2            CAN_ERROR = 1;
 601   2         }
 602   1      
 603   1         // Old SFRPAGE is popped off stack when ISR exits
 604   1      }
 605          INTERRUPT (TIMER0_ISR, INTERRUPT_TIMER0)
 606          {
 607   1        TF0 = 0;
 608   1        TL0       = 0x90; 
 609   1        TH0       = 0xE8;     //3ms,based on 2MHz clock 
 610   1      
 611   1        PIDControl();
 612   1        
 613   1      }
C51 COMPILER V9.53.0.0   MAIN                                                              06/03/2017 16:28:17 PAGE 11  

 614          INTERRUPT (TIMER2_ISR, INTERRUPT_TIMER2)
 615          {
 616   1      
 617   1      //  DisplayNumber(2);
 618   1         TF2H = 0;                           // Reset Interrupt
 619   1            // Set up the AMUX for the next ADC input
 620   1         if (AMUX_INPUT == (ANALOG_INPUTS - 1))
 621   1         {
 622   2            ADC0MX = PIN_TABLE[0] | 0x10;
 623   2         }
 624   1         else
 625   1         {
 626   2            ADC0MX = PIN_TABLE[AMUX_INPUT+1] | 0x10;
 627   2         }
 628   1         //SendMessageCAN0(EPCU_ERCP_MO,g_uTx_Data1);
 629   1         
 630   1      }
 631          
 632          
 633          /*INTERRUPT (TIMER3_ISR, INTERRUPT_TIMER3)
 634          {
 635            TMR3CN &= 0x7F;//clear flag
 636          
 637            PWM_APP *= 100;
 638            PWM_REL *= 100;
 639          
 640            PWM_Count++;
 641          
 642            if(PWM_Count > PWM_Period)
 643              PWM_Count = 0;
 644          
 645            if(PWM_Count < PWM_APP)
 646              APP_ON;
 647            else 
 648              APP_OFF;
 649          
 650            if(PWM_Count < PWM_REL)
 651              REL_ON;
 652            else
 653              REL_OFF;
 654          
 655          }
 656          */
 657          
 658          INTERRUPT (ADC0_ISR, INTERRUPT_ADC0_EOC)
 659          {
 660   1         static U16 int_dec = INT_DEC;       // Integrate/decimate counter
 661   1                                             // A new result is posted when
 662   1                                             // int_dec is 0
 663   1        
 664   1         U8 i;                               // Loop counter
 665   1      
 666   1      
 667   1         AD0INT = 0;                         // Clear ADC conversion complete
 668   1                                             // overflow
 669   1      
 670   1      
 671   1         accumulator[AMUX_INPUT] += ADC0;    // Read the ADC value and add it to the
 672   1                                             // running total
 673   1      
 674   1         // Reset sample counter <int_dec> and <AMUX_INPUT> if the final input was
 675   1         // just read
C51 COMPILER V9.53.0.0   MAIN                                                              06/03/2017 16:28:17 PAGE 12  

 676   1         if(AMUX_INPUT == (ANALOG_INPUTS - 1))
 677   1         {
 678   2            int_dec--;                       // Update decimation counter
 679   2                                             // when the last of the analog inputs
 680   2                                             // is sampled
 681   2      
 682   2            if (int_dec == 0)                // If zero, then post the averaged
 683   2            {                                // results
 684   3               int_dec = INT_DEC;            // Reset counter
 685   3      
 686   3               // Copy each averaged ADC0 value into the RESULT array
 687   3               for(i = 0; i < ANALOG_INPUTS; i++)
 688   3               {
 689   4                  // Copy averaged values into RESULT
 690   4                  RESULT[i] = accumulator[i] / int_dec;
 691   4      
 692   4                  // Reset accumulators
 693   4                  accumulator[i] = 0x00000000;
 694   4               }
 695   3            }
 696   2      
 697   2            AMUX_INPUT = 0;                  // Reset input index back to P0.1
 698   2         }
 699   1         // Otherwise, increment the AMUX channel counter
 700   1         else
 701   1         {
 702   2            AMUX_INPUT++;                    // Step to the next analog mux input
 703   2         }
 704   1         //smg_display(0xe,0xa,0xc,18);
 705   1      }
 706          
 707          
 708          
 709          
 710          
 711          void Yunzhuanwei()
 712          {
 713   1        MV53_OFF;
 714   1        MVEM_OFF;
 715   1      }
 716          void Chuzhiwei()
 717          {
 718   1        MV53_OFF;
 719   1        MVEM_OFF;
 720   1      }
 721          
 722          void Quanzhidongwei()
 723          {
 724   1        MV53_OFF;
 725   1        MVEM_OFF;
 726   1      }
 727          
 728          void Yizhiwei()
 729          {
 730   1        MV53_OFF;
 731   1        MVEM_OFF;
 732   1      }
 733          
 734          void Chonglianwei()
 735          {
 736   1        MV53_OFF;
 737   1        MVEM_OFF;
C51 COMPILER V9.53.0.0   MAIN                                                              06/03/2017 16:28:17 PAGE 13  

 738   1      }
 739          
 740          void Jinjiwei()
 741          {
 742   1        MV53_ON;
 743   1        MVEM_ON;
 744   1      }
 745          
 746          //-----------------------------------------------------------------------------
 747          // End Of File
 748          //-----------------------------------------------------------------------------


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2596    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     95      14
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
